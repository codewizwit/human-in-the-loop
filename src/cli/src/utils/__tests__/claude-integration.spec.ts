import { createClaudeCommand, isClaudeAvailable } from '../claude-integration';
import {
  readFileSync,
  writeFileSync,
  mkdirSync,
  existsSync,
} from 'fs';
import { join } from 'path';

jest.mock('fs');
jest.mock('../file-operations', () => ({
  resolvePath: (path: string) => path,
}));

const mockReadFileSync = readFileSync as jest.MockedFunction<
  typeof readFileSync
>;
const mockWriteFileSync = writeFileSync as jest.MockedFunction<
  typeof writeFileSync
>;
const mockMkdirSync = mkdirSync as jest.MockedFunction<typeof mkdirSync>;
const mockExistsSync = existsSync as jest.MockedFunction<typeof existsSync>;

describe('claude-integration', () => {
  const homeDir = '/home/user';
  const originalEnv = process.env;

  beforeEach(() => {
    jest.clearAllMocks();
    process.env = { ...originalEnv, HOME: homeDir };
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('createClaudeCommand', () => {
    describe('with markdown files', () => {
      it('should create command from markdown with frontmatter', () => {
        const markdownContent = `---
id: test-prompt
name: Test Prompt
description: A test prompt
variables:
  - name: input
    description: Test input
    required: true
---

<instructions>
Test template content
</instructions>`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        const result = createClaudeCommand('/path/to/prompt.md');

        expect(mockWriteFileSync).toHaveBeenCalledWith(
          join(homeDir, '.claude', 'commands', 'test-prompt.md'),
          expect.stringContaining('# Test Prompt'),
          'utf-8'
        );
        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('# A test prompt'),
          'utf-8'
        );
        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('# Generated by Human in the Loop CLI'),
          'utf-8'
        );
        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('{{input}} (required) - Test input'),
          'utf-8'
        );
        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('Test template content'),
          'utf-8'
        );
        expect(result).toBe(
          join(homeDir, '.claude', 'commands', 'test-prompt.md')
        );
      });

      it('should handle markdown without variables', () => {
        const markdownContent = `---
id: simple-prompt
name: Simple Prompt
description: A simple prompt
---

Simple template`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        createClaudeCommand('/path/to/prompt.md');

        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.not.stringContaining('# Variables:'),
          'utf-8'
        );
      });

      it('should handle optional variables', () => {
        const markdownContent = `---
id: optional-vars
name: Optional Variables
description: Prompt with optional vars
variables:
  - name: optionalInput
    description: Optional input
    required: false
---

Template with optional var`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        createClaudeCommand('/path/to/prompt.md');

        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('{{optionalInput}} (optional)'),
          'utf-8'
        );
      });

      it('should use custom command name if provided', () => {
        const markdownContent = `---
id: test-prompt
name: Test Prompt
description: A test prompt
---

Template content`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        const result = createClaudeCommand('/path/to/prompt.md', 'custom-name');

        expect(result).toBe(
          join(homeDir, '.claude', 'commands', 'custom-name.md')
        );
      });

      it('should throw error for invalid frontmatter', () => {
        const invalidMarkdown = `---
invalid yaml: [
---

Content`;

        mockReadFileSync.mockReturnValue(invalidMarkdown);
        mockExistsSync.mockReturnValue(true);

        expect(() => createClaudeCommand('/path/to/prompt.md')).toThrow(
          'Invalid markdown frontmatter'
        );
      });

      it('should throw error for missing frontmatter', () => {
        const noFrontmatter = 'Just plain content without frontmatter';

        mockReadFileSync.mockReturnValue(noFrontmatter);
        mockExistsSync.mockReturnValue(true);

        expect(() => createClaudeCommand('/path/to/prompt.md')).toThrow(
          'Invalid markdown frontmatter'
        );
      });

      it('should handle variables without description', () => {
        const markdownContent = `---
id: no-desc-vars
name: No Description Variables
variables:
  - name: varWithoutDesc
    required: true
---

Template`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        createClaudeCommand('/path/to/prompt.md');

        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('{{varWithoutDesc}} (required) -'),
          'utf-8'
        );
      });
    });

    describe('with YAML files', () => {
      it('should create command from YAML prompt', () => {
        const yamlContent = `id: yaml-prompt
name: YAML Prompt
description: A YAML prompt
template: |
  YAML template content
variables:
  - name: input
    description: YAML input
    required: true`;

        mockReadFileSync.mockReturnValue(yamlContent);
        mockExistsSync.mockReturnValue(true);

        const result = createClaudeCommand('/path/to/prompt.yaml');

        expect(mockWriteFileSync).toHaveBeenCalledWith(
          join(homeDir, '.claude', 'commands', 'yaml-prompt.md'),
          expect.stringContaining('# YAML Prompt'),
          'utf-8'
        );
        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.stringContaining('YAML template content'),
          'utf-8'
        );
        expect(result).toBe(
          join(homeDir, '.claude', 'commands', 'yaml-prompt.md')
        );
      });

      it('should handle YAML without variables', () => {
        const yamlContent = `id: simple-yaml
name: Simple YAML
description: Simple YAML prompt
template: Simple template`;

        mockReadFileSync.mockReturnValue(yamlContent);
        mockExistsSync.mockReturnValue(true);

        createClaudeCommand('/path/to/prompt.yaml');

        expect(mockWriteFileSync).toHaveBeenCalledWith(
          expect.any(String),
          expect.not.stringContaining('# Variables:'),
          'utf-8'
        );
      });
    });

    describe('directory creation', () => {
      it('should create .claude directory if it does not exist', () => {
        const markdownContent = `---
id: test
name: Test
---
Content`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValueOnce(false); // .claude doesn't exist
        mockExistsSync.mockReturnValueOnce(false); // commands doesn't exist

        createClaudeCommand('/path/to/prompt.md');

        expect(mockMkdirSync).toHaveBeenCalledWith(
          join(homeDir, '.claude'),
          { recursive: true }
        );
        expect(mockMkdirSync).toHaveBeenCalledWith(
          join(homeDir, '.claude', 'commands'),
          { recursive: true }
        );
      });

      it('should not create directories if they already exist', () => {
        const markdownContent = `---
id: test
name: Test
---
Content`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        createClaudeCommand('/path/to/prompt.md');

        expect(mockMkdirSync).not.toHaveBeenCalled();
      });

      it('should use USERPROFILE on Windows if HOME is not set', () => {
        process.env = { ...originalEnv, USERPROFILE: 'C:\\Users\\test' };
        delete process.env.HOME;

        const markdownContent = `---
id: test
name: Test
---
Content`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        const result = createClaudeCommand('/path/to/prompt.md');

        expect(result).toContain('C:\\Users\\test');
      });

      it('should fallback to ~ if no home directory is set', () => {
        process.env = {};

        const markdownContent = `---
id: test
name: Test
---
Content`;

        mockReadFileSync.mockReturnValue(markdownContent);
        mockExistsSync.mockReturnValue(true);

        const result = createClaudeCommand('/path/to/prompt.md');

        expect(result).toContain('~');
      });
    });
  });

  describe('isClaudeAvailable', () => {
    it('should return true if .claude directory exists', () => {
      mockExistsSync.mockReturnValue(true);

      expect(isClaudeAvailable()).toBe(true);
      expect(mockExistsSync).toHaveBeenCalledWith(
        join(homeDir, '.claude')
      );
    });

    it('should create .claude directory if it does not exist', () => {
      mockExistsSync.mockReturnValue(false);

      expect(isClaudeAvailable()).toBe(true);
      expect(mockMkdirSync).toHaveBeenCalledWith(
        join(homeDir, '.claude'),
        { recursive: true }
      );
    });

    it('should return false if HOME is not set', () => {
      process.env = {};

      expect(isClaudeAvailable()).toBe(false);
    });

    it('should return false if directory creation fails', () => {
      mockExistsSync.mockReturnValue(false);
      mockMkdirSync.mockImplementation(() => {
        throw new Error('Permission denied');
      });

      expect(isClaudeAvailable()).toBe(false);
    });

    it('should use USERPROFILE on Windows', () => {
      process.env = { ...originalEnv, USERPROFILE: 'C:\\Users\\test' };
      delete process.env.HOME;

      mockExistsSync.mockReturnValue(true);

      expect(isClaudeAvailable()).toBe(true);
      expect(mockExistsSync).toHaveBeenCalledWith(
        expect.stringContaining('.claude')
      );
    });
  });
});
