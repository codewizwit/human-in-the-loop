id: code-review-empathy
name: Code Review Empathy Guide
version: 1.0.0
description: Transforms harsh or unclear code review feedback into empathetic, constructive comments that balance critique with appreciation and provide actionable guidance
category: culture

variables:
  - name: feedback
    description: The original code review comment or feedback to rewrite
    required: true
  - name: code_context
    description: Optional code snippet or context being reviewed
    required: false
  - name: reviewer_intent
    description: What the reviewer is trying to communicate (e.g., security concern, performance issue, style preference)
    required: false

template: |
  You are an expert at providing empathetic, constructive code review feedback. Your goal is to help reviewers communicate effectively while maintaining team morale and psychological safety.

  ## Original Feedback
  {{feedback}}

  {{#if code_context}}
  ## Code Being Reviewed
  {{code_context}}
  {{/if}}

  {{#if reviewer_intent}}
  ## Reviewer's Intent
  {{reviewer_intent}}
  {{/if}}

  ## Your Task
  Rewrite the feedback above using these empathy principles:

  1. **Start with Appreciation**
     - Acknowledge what's working well
     - Recognize the effort and intent behind the code
     - Find something positive even in code that needs changes

  2. **Be Specific and Actionable**
     - Point to exact lines or patterns
     - Explain *why* something matters (not just *what* is wrong)
     - Provide concrete examples or suggestions

  3. **Use Collaborative Language**
     - Replace "you" with "we" or "this code"
     - Frame as questions or suggestions, not commands
     - Assume good intent and competence

  4. **Balance Critique with Context**
     - Distinguish between blocking issues vs. suggestions
     - Explain the trade-offs and reasoning
     - Invite discussion rather than dictating solutions

  5. **Maintain Professional Respect**
     - Avoid sarcasm, judgment, or dismissive language
     - Focus on the code, not the person
     - Use encouraging, growth-oriented tone

  ## Output Format
  Provide your rewritten feedback in this structure:

  **Rewritten Feedback:**
  [Your empathetic version of the feedback]

  **Key Changes Made:**
  - [Bulleted list of specific improvements you made to the tone/content]

  **Severity Level:** [Blocking | Important | Suggestion | Nitpick]

  **Why This Matters:**
  [Brief explanation of the technical or team impact]

examples:
  - input:
      feedback: "This is terrible. You're using any types everywhere. Did you even read the TypeScript docs?"
      code_context: |
        function processData(data: any) {
          return data.map((item: any) => item.value);
        }
      reviewer_intent: 'Type safety is important for maintainability'
    output: |
      **Rewritten Feedback:**
      Thanks for getting this function working! I can see the logic flow is solid. I noticed we're using `any` types here, which will make it harder to catch bugs at compile time. Would you be open to defining interfaces for the data structures?

      Here's what I'm thinking:
      ```typescript
      interface DataItem {
        value: number;
      }

      function processData(data: DataItem[]): number[] {
        return data.map((item) => item.value);
      }
      ```

      This way TypeScript can help us catch issues if the data shape changes. What do you think?

      **Key Changes Made:**
      - Started with appreciation for the working logic
      - Removed judgmental language ("terrible", "did you even")
      - Used "we" instead of "you" to create collaboration
      - Provided a concrete code example
      - Framed as a question inviting discussion
      - Explained the benefit (catching bugs) not just the rule

      **Severity Level:** Important

      **Why This Matters:**
      Type safety prevents runtime errors and makes refactoring safer. It's particularly important in shared codebases where multiple developers rely on consistent interfaces.

  - input:
      feedback: 'Why would you do it this way? Just use the built-in method.'
      code_context: |
        const sum = arr.reduce((acc, val) => acc + val, 0) / arr.length;
      reviewer_intent: "There's a more concise approach available"
    output: |
      **Rewritten Feedback:**
      Nice work calculating the average! I see you're using `reduce` here, which definitely works.

      I wanted to share an alternative approach that might be slightly more readable - we could separate the sum and division:
      ```typescript
      const sum = arr.reduce((acc, val) => acc + val, 0);
      const average = sum / arr.length;
      ```

      Or if we want to be more explicit about handling empty arrays:
      ```typescript
      const average = arr.length > 0
        ? arr.reduce((acc, val) => acc + val, 0) / arr.length
        : 0;
      ```

      Both approaches work - curious if you have a preference or if there's a reason you went with the single-line version?

      **Key Changes Made:**
      - Removed dismissive tone ("why would you")
      - Acknowledged the current solution works
      - Presented alternatives as options, not corrections
      - Added edge case consideration (empty arrays)
      - Invited discussion about trade-offs

      **Severity Level:** Suggestion

      **Why This Matters:**
      Readability helps future maintainers (including our future selves) understand the code quickly. Edge case handling prevents potential division-by-zero errors.

  - input:
      feedback: 'This will never scale. Completely wrong approach.'
      code_context: |
        for (const user of users) {
          await db.updateUser(user.id, user.data);
        }
      reviewer_intent: 'Sequential database calls will be slow with large datasets'
    output: |
      **Rewritten Feedback:**
      Great job getting the user updates working! I want to flag a potential performance concern for when this code runs with larger datasets.

      Right now we're updating users sequentially (one at a time), which works fine for small batches but could become slow as we scale. Each `await` waits for the previous update to finish before starting the next one.

      Would you be open to batching these updates? Here's one approach:
      ```typescript
      await Promise.all(
        users.map(user => db.updateUser(user.id, user.data))
      );
      ```

      This runs all updates in parallel, which should be much faster for large datasets. The trade-off is we lose fine-grained error handling - we might want to add a try/catch or use `Promise.allSettled` if we need to handle partial failures.

      Happy to pair on this if you'd like to discuss the trade-offs!

      **Key Changes Made:**
      - Started with recognition that the code works
      - Specified *when* the issue matters (scale/large datasets)
      - Explained the performance impact clearly
      - Provided a concrete solution with code example
      - Acknowledged trade-offs honestly
      - Offered to collaborate on the solution

      **Severity Level:** Important

      **Why This Matters:**
      Sequential async operations can create major performance bottlenecks at scale. A batch of 1000 users taking 100ms each would take 100 seconds sequentially vs ~100ms in parallel.

metadata:
  author: codewizwit
  license: MIT
  tags:
    - culture
    - code-review
    - communication
    - empathy
    - feedback
    - team-dynamics
  lastUpdated: '2025-10-15'
