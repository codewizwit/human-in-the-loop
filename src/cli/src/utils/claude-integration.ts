import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { parse as parseYaml } from 'yaml';
import { resolvePath } from './file-operations';

/**
 * Interface for prompt YAML structure
 */
interface PromptYaml {
  id: string;
  name: string;
  description: string;
  template: string;
  variables?: Array<{
    name: string;
    description: string;
    required: boolean;
  }>;
}

/**
 * Extracts frontmatter and content from markdown
 * @param content - Markdown content with frontmatter
 * @returns Object with frontmatter data and content body
 */
function parseFrontmatter(content: string): {
  data: unknown;
  content: string;
} | null {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);

  if (!match) {
    return null;
  }

  try {
    const data = parseYaml(match[1]) as unknown;
    const body = match[2];
    return { data, content: body };
  } catch {
    return null;
  }
}

/**
 * Creates a Claude Code slash command from a prompt template
 * @param promptPath - Path to the prompt.yaml or prompt.md file
 * @param commandName - Name for the slash command (defaults to prompt id)
 * @returns Path to the created command file
 */
export function createClaudeCommand(
  promptPath: string,
  commandName?: string
): string {
  const homeDir = process.env.HOME || process.env.USERPROFILE || '~';
  const claudeDir = resolvePath(join(homeDir, '.claude'));
  const commandsDir = join(claudeDir, 'commands');

  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }
  if (!existsSync(commandsDir)) {
    mkdirSync(commandsDir, { recursive: true });
  }

  let commandContent: string;
  let cmdName: string;

  if (promptPath.endsWith('.md')) {
    const content = readFileSync(promptPath, 'utf-8');
    const parsed = parseFrontmatter(content);

    if (!parsed || !parsed.data || typeof parsed.data !== 'object') {
      throw new Error('Invalid markdown frontmatter');
    }

    const frontmatter = parsed.data as {
      id?: string;
      name?: string;
      description?: string;
      variables?: Array<{
        name: string;
        description?: string;
        required?: boolean;
      }>;
    };
    cmdName = commandName || frontmatter.id || 'unknown';

    commandContent = generateMarkdownCommandContent(
      frontmatter,
      parsed.content
    );
  } else {
    const yamlContent = readFileSync(promptPath, 'utf-8');
    const prompt = parseYaml(yamlContent) as PromptYaml;

    cmdName = commandName || prompt.id;
    commandContent = generateCommandContent(prompt);
  }

  const commandFilePath = join(commandsDir, `${cmdName}.md`);
  writeFileSync(commandFilePath, commandContent, 'utf-8');

  return commandFilePath;
}

/**
 * Generates the markdown content for a Claude Code command from markdown frontmatter
 * @param frontmatter - The parsed frontmatter data
 * @param content - The prompt template content
 * @returns Markdown content for the command file
 */
function generateMarkdownCommandContent(
  frontmatter: {
    name?: string;
    description?: string;
    variables?: Array<{
      name: string;
      description?: string;
      required?: boolean;
    }>;
  },
  content: string
): string {
  const lines: string[] = [];

  if (frontmatter.name) {
    lines.push(`# ${frontmatter.name}\n`);
  }
  if (frontmatter.description) {
    lines.push(`# ${frontmatter.description}\n`);
  }
  lines.push(`# Generated by Human in the Loop CLI\n`);

  if (frontmatter.variables && frontmatter.variables.length > 0) {
    lines.push(`# Variables:`);
    for (const variable of frontmatter.variables) {
      const required = variable.required ? '(required)' : '(optional)';
      const desc = variable.description || '';
      lines.push(`#   {{${variable.name}}} ${required} - ${desc}`);
    }
    lines.push('');
  }

  lines.push(content);

  return lines.join('\n');
}

/**
 * Generates the markdown content for a Claude Code command from YAML
 * @param prompt - The parsed prompt YAML
 * @returns Markdown content for the command file
 */
function generateCommandContent(prompt: PromptYaml): string {
  const lines: string[] = [];

  lines.push(
    `# ${prompt.name}\n`,
    `# ${prompt.description}\n`,
    `# Generated by Human in the Loop CLI\n`
  );

  if (prompt.variables && prompt.variables.length > 0) {
    lines.push(`# Variables:`);
    for (const variable of prompt.variables) {
      const required = variable.required ? '(required)' : '(optional)';
      lines.push(
        `#   {{${variable.name}}} ${required} - ${variable.description}`
      );
    }
    lines.push('');
  }

  lines.push(prompt.template);

  return lines.join('\n');
}

/**
 * Checks if Claude Code integration is available
 * @returns true if .claude directory exists or can be created
 */
export function isClaudeAvailable(): boolean {
  try {
    const homeDir = process.env.HOME || process.env.USERPROFILE;
    if (!homeDir) {
      return false;
    }

    const claudeDir = join(homeDir, '.claude');

    if (existsSync(claudeDir)) {
      return true;
    }

    mkdirSync(claudeDir, { recursive: true });
    return true;
  } catch {
    return false;
  }
}
