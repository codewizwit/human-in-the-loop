import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { parse as parseYaml } from 'yaml';
import { resolvePath } from './file-operations';

/**
 * Interface for prompt YAML structure
 */
interface PromptYaml {
  id: string;
  name: string;
  description: string;
  template: string;
  variables?: Array<{
    name: string;
    description: string;
    required: boolean;
  }>;
}

/**
 * Extracts frontmatter and content from markdown
 * @param content - Markdown content with frontmatter
 * @returns Object with frontmatter data and content body
 */
function parseFrontmatter(content: string): {
  data: unknown;
  content: string;
} | null {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = content.match(frontmatterRegex);

  if (!match) {
    return null;
  }

  try {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const data = parseYaml(match[1]);
    const body = match[2];
    return { data, content: body };
  } catch {
    return null;
  }
}

/**
 * Creates a Claude Code slash command from a prompt template
 * @param promptPath - Path to the prompt.yaml or prompt.md file
 * @param commandName - Name for the slash command (defaults to prompt id)
 * @returns Path to the created command file
 */
export function createClaudeCommand(
  promptPath: string,
  commandName?: string
): string {
  // Determine .claude/commands directory
  const homeDir = process.env.HOME || process.env.USERPROFILE || '~';
  const claudeDir = resolvePath(join(homeDir, '.claude'));
  const commandsDir = join(claudeDir, 'commands');

  // Create directories if they don't exist
  if (!existsSync(claudeDir)) {
    mkdirSync(claudeDir, { recursive: true });
  }
  if (!existsSync(commandsDir)) {
    mkdirSync(commandsDir, { recursive: true });
  }

  let commandContent: string;
  let cmdName: string;

  // Check if it's a markdown file
  if (promptPath.endsWith('.md')) {
    // For markdown files, extract frontmatter to get the ID
    const content = readFileSync(promptPath, 'utf-8');
    const parsed = parseFrontmatter(content);

    if (!parsed || !parsed.data || typeof parsed.data !== 'object') {
      throw new Error('Invalid markdown frontmatter');
    }

    const frontmatter = parsed.data as { id?: string };
    cmdName = commandName || frontmatter.id || 'unknown';

    // Use the entire markdown content (frontmatter will be stripped naturally)
    commandContent = parsed.content;
  } else {
    // Legacy YAML handling
    const yamlContent = readFileSync(promptPath, 'utf-8');
    const prompt = parseYaml(yamlContent) as PromptYaml;

    cmdName = commandName || prompt.id;
    commandContent = generateCommandContent(prompt);
  }

  // Write the command file
  const commandFilePath = join(commandsDir, `${cmdName}.md`);
  writeFileSync(commandFilePath, commandContent, 'utf-8');

  return commandFilePath;
}

/**
 * Generates the markdown content for a Claude Code command
 * @param prompt - The parsed prompt YAML
 * @returns Markdown content for the command file
 */
function generateCommandContent(prompt: PromptYaml): string {
  const lines: string[] = [];

  // Add header comment
  lines.push(
    `# ${prompt.name}\n`,
    `# ${prompt.description}\n`,
    `# Generated by Human in the Loop CLI\n`
  );

  // Add variable instructions if present
  if (prompt.variables && prompt.variables.length > 0) {
    lines.push(`# Variables:`);
    for (const variable of prompt.variables) {
      const required = variable.required ? '(required)' : '(optional)';
      lines.push(
        `#   {{${variable.name}}} ${required} - ${variable.description}`
      );
    }
    lines.push('');
  }

  // Add the template content
  lines.push(prompt.template);

  return lines.join('\n');
}

/**
 * Checks if Claude Code integration is available
 * @returns true if .claude directory exists or can be created
 */
export function isClaudeAvailable(): boolean {
  try {
    const homeDir = process.env.HOME || process.env.USERPROFILE;
    if (!homeDir) {
      return false;
    }

    const claudeDir = join(homeDir, '.claude');

    // Check if it exists or can be created
    if (existsSync(claudeDir)) {
      return true;
    }

    // Try to create it
    mkdirSync(claudeDir, { recursive: true });
    return true;
  } catch {
    return false;
  }
}
