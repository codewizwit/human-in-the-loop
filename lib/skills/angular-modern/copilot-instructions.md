---
applyTo: '**/*.ts,**/*.component.ts,**/*.service.ts,**/*.html'
---

# Angular Modern Development (Angular 16+)

This project uses **modern Angular 16+ patterns** with signals, computed values, effects, and standalone components. Follow these guidelines:

## Core Principles

1. **Use Signals for State** - All component state should use `signal()`, NOT class properties
2. **Standalone Components** - NO `NgModules`, all components are `standalone: true`
3. **Signal-Based I/O** - Use `input()` and `output()`, NOT `@Input()` / `@Output()` decorators
4. **No Lifecycle Hooks** - NO `ngOnInit`, `ngOnDestroy` - use constructor or field initializers
5. **Modern Control Flow** - Use `@if`, `@for`, `@switch`, NOT `*ngIf`, `*ngFor`, `*ngSwitch`

## State Management

```typescript
// ✅ CORRECT: Use signals
count = signal(0);
user = signal<User | null>(null);

// ✅ CORRECT: Use computed for derived state
doubleCount = computed(() => this.count() * 2);
isLoggedIn = computed(() => this.user() !== null);

// ❌ WRONG: Don't use class properties
count = 0;
user: User | null = null;
```

## Component Inputs and Outputs

```typescript
// ✅ CORRECT: Signal-based inputs/outputs
export class ProductCard {
  product = input.required<Product>();
  featured = input(false);
  addToCart = output<Product>();
}

// ❌ WRONG: Don't use decorators
export class ProductCard {
  @Input() product!: Product;
  @Output() addToCart = new EventEmitter<Product>();
}
```

## Templates and Control Flow

```typescript
// ✅ CORRECT: Modern control flow
template: `
  @if (isLoggedIn()) {
    <p>Welcome, {{ username() }}</p>
  } @else {
    <button>Log In</button>
  }

  @for (item of items(); track item.id) {
    <div>{{ item.name }}</div>
  } @empty {
    <p>No items</p>
  }
`;

// ❌ WRONG: Don't use structural directives
template: `
  <p *ngIf="isLoggedIn">Welcome</p>
  <div *ngFor="let item of items; trackBy: trackById">{{ item.name }}</div>
`;
```

## Effects for Side Effects

```typescript
// ✅ CORRECT: Use effect() for side effects
constructor() {
  effect(() => {
    const theme = this.theme();
    localStorage.setItem('theme', theme);
    document.documentElement.setAttribute('data-theme', theme);
  });
}

// ❌ WRONG: Don't use ngOnInit
ngOnInit() {
  localStorage.setItem('theme', this.theme);
}
```

## Data Loading

```typescript
// ✅ CORRECT: Use resource() API (Angular 19+)
userResource = resource({
  request: () => ({ id: this.userId() }),
  loader: async ({ request }) => {
    const response = await fetch(`/api/users/${request.id}`);
    return response.json();
  }
});

// Access in template:
@if (userResource.isLoading()) {
  <p>Loading...</p>
}
@if (userResource.hasValue()) {
  <div>{{ userResource.value().name }}</div>
}

// ❌ WRONG: Don't use RxJS subscriptions
ngOnInit() {
  this.userService.getUser(this.userId).subscribe(user => {
    this.user = user;
  });
}
```

## Standalone Component Structure

```typescript
// ✅ CORRECT: Standalone component
@Component({
  selector: 'app-user-profile',
  standalone: true,
  imports: [CommonModule, RouterLink, UserCardComponent],
  template: `...`,
})
export class UserProfileComponent {
  // Component logic
}

// ❌ WRONG: Don't use NgModules
@NgModule({
  declarations: [UserProfileComponent],
  imports: [CommonModule],
})
export class UserProfileModule {}
```

## Key Anti-Patterns to Avoid

❌ **NO** `ngOnInit`, `ngOnDestroy`, `ngOnChanges` lifecycle hooks
❌ **NO** `@Input()` / `@Output()` decorators - use `input()` / `output()`
❌ **NO** `*ngIf`, `*ngFor`, `*ngSwitch` - use `@if`, `@for`, `@switch`
❌ **NO** RxJS subscriptions for component state - use signals
❌ **NO** `NgModules` - use standalone components
❌ **NO** manual subscription management - use `resource()` or async pipe
❌ **NO** class properties for state - use `signal()`
❌ **NO** effects for derived state - use `computed()`

## Best Practices

✅ **DO** use `signal()` for all component state
✅ **DO** use `computed()` for derived values
✅ **DO** use `effect()` ONLY for side effects (DOM, localStorage, logging)
✅ **DO** use `input()` and `output()` for component APIs
✅ **DO** use `resource()` for async data loading
✅ **DO** use `@if`, `@for`, `@switch` control flow
✅ **DO** make all components `standalone: true`
✅ **DO** use immutable updates with signals: `.update(val => ({ ...val, prop: newValue }))`

## Testing

```typescript
// Test signals directly
it('should increment count', () => {
  component.count.set(0);
  component.increment();
  expect(component.count()).toBe(1);
});

// Test computed values
it('should compute double count', () => {
  component.count.set(5);
  expect(component.doubleCount()).toBe(10);
});
```

---

**Generated by Human-in-the-Loop AI Hub**
Framework expertise for modern Angular development
